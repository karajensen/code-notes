/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QT MODELING LANGUAGE (QML)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QML MEMORY ALLOCATION
• Using QML allocates both in C++ heap and javascript garbage collected heap
• WorkerScripts share their own seperate Javascript heap, only allocated if WorkerScript is used
• Adding custom properties makes it an implicit type of the component (allocates memory for new type) 
• Not adding custom properties makes it an explicit type of the component (shares memory for type)
• Order of children OnCompleted is undefined, parent OnCompleted called when all children OnCompleted are called

C++ HEAP ALLOCATIONS:
• Overhead of the QML engine (implementation data structures, context information)
• Per-component compiled data and type information, depending which modules/components used
• Per-object C++ data/property values, plus metaobject hierarchy, depending which modules/components used
• Any data which is allocated specifically by QML libraries

JAVASCRIPT HEAP ALLOCATIONS:
• Javascript engine itself including built in types
• Javascript integration: constructor functions for loaded types, function templates
• Variables allocated during expression evaluation
• Per-type layout information and other internal type-data generated by the JavaScript engine at runtime
• Per-object JavaScript data: var properties, functions/signal handlers, non-optimized binding expressions
**************************************************************************************************************/
    
import QtQuick.Layouts 1.3
import QtQuick.Controls 2.3
import QtQuick.Controls 1.4 as ControlsLegacy
import QtQuick.Dialogs 1.2 as DialogLegacy
import MyEnums 1.0    // Requires registering with QQmlEngine
import MyGlobals 1.0  // Requires registering with QQmlEngine
import "MyJavascript.js" as MyJS

Item {
    id: item                               // unique id of item, can be used to access it
    property int myProperty: 0             // custom property
    property int myProperty: myProperty2   // if myProperty2 changes, re-evaluates myProperty
    property int myProperty: myFunction    // if properties used in function changes, re-evaluates myProperty
    property int myProperty: { return 0; } // if properties used in function changes, re-evaluates myProperty
    property int myProperty: MyJS.fn       // Use function from imported javascript file
    property int myProperty: MyGlobal.fn   // Use function from singleton, Requires registering with QQmlEngine
    property int myProperty: MyEnum.ONE    // Use int type for enums, Requires registering with QQmlEngine
    property var myProperty: myObj         // Context Q_OBJECT, Requires registering with QQuickView
    property int myProperty: myObj.value   // Context Q_OBJECT with Q_PROPERTY 'value' with NOTIFY
    property Item myItem: Rectangle {}     // QML component as a property, creates instance
    property Component myItem: Item {}     // QML component as a property, does not create instance
    readonly property int myProperty: 0    // read-only property
    required property int myProperty       // Must be set when component used, cannot be assigned in onComplete
    property alias myAlias: myProperty     // reference for property
    signal mySignal(int value)             // call with item.mySignal(0)
      
    /* Attached Property, Called when the item has been instantiated */
    Component.onCompleted: {}

    /* Attached Property, Called when the item is destroyed */
    Component.onDestruction: {}

    /* Called when property has changed, for context Q_OBJECTs emit signal needed */
    onMyPropertyChanged: {}
  
    /* Called when signal emitted, 'value' arg passed in */
    onMySignal: { value }
  
    /* Called when signal emitted, requires calling signal.connect */
    function mySlot(value) {}
    
    /* Use a specific namespace control */
    ControlsLegacy.Rectangle {}

    /* Javascript custom function */
    function myFunction(x, y) {
        return x + y;
    }  
    
    /* QML only enum */
    enum MyEnum {
        ZERO,
        ONE,
        TWO
    }
    property int myEnum: MyQml.MyEnum.ZERO // Must use QML file/component name
}

mySignal.connect(mySlot) // Connect signal and slot, forward optional, no auto disconnect
mySignal.disconnect(mySlot) // Signals must be disconnected
myProp1 = value // Sets value of property and kills the binding- to not break, call setProperty on object in cpp
myProp1 = Qt.binding(function() { return myProp2; }) // Set a binding on a property, will eval in-place as well
item instanceof MyItem // Returns true if item is of type MyItem

// GLOBAL OBJECTS
// MyGlobal.qml, Requires registering with QQmlEngine
pragma Singleton
import QtQuick 2.4
QtObject {
    property value: 0
    function fn() {
        return 0;
    }
}

// JAVASCRIPT FILES
// MyJavascript.js, Makes a library to enable sharing across all QML files
var value = 0;
function fn() {
    return 0;
}

// JAVASCRIPT LIMITATIONS
function fn() {
    myGlobalVar = 10; // CANNOT modify global properties, use 'var' instead
    this.myProperty = 10; // CANNOT use 'this', in most places is undefined, use id instead
}

// LOG QML ITEM PROPERTIES
console.error(JSON.stringify(myQmlComponent));
console.error(JSON.stringify(myObject));
for (var key in myObject) { 
    console.error(key);
    console.error(myObject[key]);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML INHERITANCE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// OVERRIDING PROPERTIES
Item /*MyBase.qml*/ {
    property int myProperty: 10 // MyBase.qml uses 10
    property int myDerivedProperty: 0
    property alias myBaseProperty: myProperty
}
MyBaseQml /*MyDerived.qml*/ {
    property int myProperty: 20 // MyDerived.qml and any uses of it uses 20
    myDerivedProperty: myProperty
}

// DEFAULT PROPERTIES
// Useful for positioning derived components inside base components
Item /*MyBase.qml*/ {
    default property alias contentItem: holder.children
    Item {
        id: holder
    }
}
MyBase /*MyDerived.qml*/ {
    // Can omit the contentItem, can be array of items or many child items
    contentItem: Rectangle {
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML BASIC TYPES
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property bool myBool: true
property double myDouble: 0.0
property int myInt: 0
property real myReal: 0.0
  
// VAR
// Use for holding Javascript objects, QObjects, Qt containers and variant
// Javascript object attributes do not send signal or update bindings when changed
property var myFn: (function() { return 0; }) // Javascript function
property var myObj: { "a":0, "b":1 } // Javascript object
property var myObj: ({ a:0, b:1 }) // Javascript object, requires () without "
property var myObj: new Object({ "a":0, "b":1 }) // Javascript object
property int myAttr: myObj.a // Will not update when 'a' updates
property var myArray: [1, 2, 3, "a", "b"] // Javascript array
property var myArray: myObj.myQtContainerArray // Javascript modified array
  
// LIST
// list of QML objects, not a Javascript array
// Auto converts to/from QmlListProperty<T> or QVariantList
property list myList
myList.length // item count in list
myList[index] // access item
  
// POINT
// Auto converts to/from QPoint and QPoint
// Attributes do not have signals, use onMyPointChanged instead
property point myPoint: Qt.point(0, 20)
property point myPoint: "0,20"
myPoint.x / myPoint.y
  
// RECT
// Auto converts to/from QRect and QRectF
// Attributes do not have signals, use onMyRectChanged instead
property rect myRect: "50,50,100x100"
property rect myRect: Qt.rect(50, 50, 100, 100)
myRect.x / myRect.y
myRect.width
myRect.height
myRect.top // read-only
myRect.bottom // read-only
myRect.left // read-only
myRect.right // read-only

// SIZE
// Auto converts to/from QSize and QSizeF
// Attributes do not have signals, use onMySizeChanged instead
property size mySize: "150x50"
property size mySize: Qt.size(150, 50)
mySize.width
mySize.height

// URL
// Auto converts to/from QUrl
property url myUrl: "folder/image.png" // Relative path, will be converted to absolute
property url myUrl: "file:///folder/image.png" // Absolute path
property url myUrl: "qrc:///folder/image.png" // Resource path
myUrl == Qt.resolvedUrl("folder/image.png") // Comparison
myUrl.toString() // Returns the absolute path
Qt.resolvedUrl(myUrl) // Returns url resolved relative to the URL of the caller

// STRING
// Auto converts to/from QString
// Attributes do not have signals, use onMyStrChanged instead
property string myStr: "str"
property string myStr: value.toLocaleString(Qt.locale(), 'f', 0)
myStr.length
myStr.arg(10) // Replace %1, %2 etc with value, can chain
Qt.qsTrId(id) // returns translated string at id, else id if no translation
Qt.qsTrIdNoOp(id) // Marks id for dynamic translation, returns id

//===========================================================================================================
// QML DATE
//===========================================================================================================

// DATE
// Auto converts to/from QDate and QDateTime
property date myDate: "2020-12-31"
  
// Takes JavaScript Date or QML date, returns date as string
// Format defaults Qt.SystemLocaleShortDate, can be Date Format Enum or Date Format String
Qt.formatDate(date, format)
Qt.formatDateTime(date, format)
Qt.formatTime(date, format)
  
// Date Format Enum
Qt.TextDate                // ddd MMM d yyyy
Qt.ISODate                 // yyyy-MM-dd or yyyy-MM-ddTHH:mm:ss or with a time-zone suffix 
Qt.ISODateWithMs           // Qt.ISODate with ms
Qt.SystemLocaleShortDate   // The short format used by the operating system
Qt.SystemLocaleLongDate    // The long format used by the operating system
Qt.DefaultLocaleShortDate  // The short format specified by the application's locale
Qt.DefaultLocaleLongDate   // The long format specified by the application's locale
  
// Date Format String
// Can use space . and : to seperate (eg. "ddd MMMM d yy" )
d     // the day as number without a leading zero (1 to 31)
dd    // the day as number with a leading zero (01 to 31)
ddd   // the abbreviated localized day name (e.g. 'Mon' to 'Sun'). Uses QDate::shortDayName()
dddd  // the long localized day name (e.g. 'Monday' to 'Qt::Sunday'). Uses QDate::longDayName()
M     // the month as number without a leading zero (1-12)
MM    // the month as number with a leading zero (01-12)
MMM   // the abbreviated localized month name (e.g. 'Jan' to 'Dec'). Uses QDate::shortMonthName()
MMMM  // the long localized month name (e.g. 'January' to 'December'). Uses QDate::longMonthName()
yy    // the year as two digit number (00-99)
yyyy  // the year as four digit number
h     // the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
hh    // the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
m     // the minute without a leading zero (0 to 59)
mm    // the minute with a leading zero (00 to 59)
s     // the second without a leading zero (0 to 59)
ss    // the second with a leading zero (00 to 59)
z     // the milliseconds without leading zeroes (0 to 999)
zzz   // the milliseconds with leading zeroes (000 to 999)
AP    // use AM/PM display. AP will be replaced by either "AM" or "PM"
ap    // use am/pm display. ap will be replaced by either "am" or "pm"
t     // include a time-zone indicator

//===========================================================================================================
// QML COLOR
//===========================================================================================================

// COLOR
// ARGB color value, auto converts to/from QColor
// Attributes do not have signals, use onMyColorChanged instead
property color myColor: "red"
property color myColor: "#RRGGBB"
property color myColor: "#AARRGGBB"
property color myColor: Qt.rgba(r, g, b, a) // All real in range [0.0,1.0]
Qt.hsva(hue, saturation, value, alpha) // All real in range [0.0,1.0]
Qt.hsla(hue, saturation, lightness, alpha) // All real in range [0.0,1.0]
Qt.darker(myColor, v) // Returns darker color by converting to HSV then value/v, v <= 0 unspecified
Qt.darker(myColor) // Returns color 50% darker than myColor
Qt.lighter(myColor, v) // Returns lighter color by converting to HSV then value*v, v <= 0 unspecified
Qt.lighter(myColor) // Returns color 50% lighter than myColor
Qt.tint(myColor, tintColor) // Returns color with tintColor overlaying myColor
Qt.colorEqual(myColor, myColor2) // Either argument can be Color or string type
myColor.toString().toUpperCase() // Returns name in hex format
myColor.r / myColor.g / myColor.b / myColor.a
myColor.hsvHue
myColor.hsvSaturation
myColor.hsvValue 
myColor.hslHue
myColor.hslSaturation
myColor.hslLightness

// PALETTE
// Each property is QML color
property palette myPalette
myPalette.alternateBase // Alternate background color in item views with alternating row colors
myPalette.base // Background color for text editor controls and items views
myPalette.brightText // Text color that contrasts well with palette.dark, used on  highlighted buttons
myPalette.button // General button background color
myPalette.buttonText // Foreground color used with the palette.button color
myPalette.dark // Darker than palette.button
myPalette.highlight // Color to indicate a selected item or the current item
myPalette.highlightedText // Text color that contrasts with palette.highlight
myPalette.light // Lighter than palette.button
myPalette.link // Text color used for hyperlinks
myPalette.linkVisited // Text color used for already visited hyperlinks
myPalette.mid // Between palette.button and palette.dark
myPalette.midlight // Between palette.button and palette.light
myPalette.shadow // A very dark color
myPalette.text // Foreground color used with palette.base
myPalette.toolTipBase // Used as the background color for tooltips
myPalette.toolTipText // Used as the foreground color for tooltips
myPalette.window // General background color
myPalette.windowText // General foreground color

//===========================================================================================================
// QML MATH
//===========================================================================================================

// MATRIX4X4
// Attributes do not have signals, use onMyMatChanged instead
property matrix4x4 myMat: Qt.matrix4x4(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
myMat.m11...myMat.m44
myMat.column(index) // returns vector4d, zero-based index
myMat.determinant() // returns real
myMat.fuzzyEquals(myMat2, epsilon) // epsilon is real
myMat.inverted() // returns myMat inverted
myMat.minus(myMat2) // myMat - myMat2
myMat.plus(myMat2) // myMat + myMat2
myMat.row(index) // returns vector4d, zero-based index
myMat.times(myMat2) // multiplying myMat with myMat4
myMat.times(myVec) // transforming vector3d or vector4d with the 4x4 matrix
myMat.times(value) // multiply matrix by real scalar
myMat.toString()
myMat.transposed() // returns myMat transposed

// QUATERNION
// Attributes do not have signals, use onMyQuatChanged instead
property quaternion myQuat: "1.0,0,1,0" // scalar,x,y,z
property quaternion myQuat: Qt.quaternion(1.0,0,1,0) // scalar,x,y,z
myQuat.x / myQuat.y / myQuat.z
myQuat.scalar

// VECTOR2D
// Attributes do not have signals, use onMyVecChanged instead
property vector2d myVec: "0,1"
property vector2d myVec: Qt.vector2d(0,1)
myVec.x / myVec.y
myVec.dotProduct(myVec2) // returns real
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector3d() // returns vector3d, z component is set to 0
myVec.toVector4d() // returns vector4d, z/w components set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR3D
// Attributes do not have signals, use onMyVecChanged instead
// Converts to/from QVector3D
property vector3d myVec: "0,1,0"
property vector3d myVec: Qt.vector3d(0,1,0)
myVec.x / myVec.y / myVec.z
myVec.crossProduct(myVec2) // returns vector x vector2
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z component dropped
myVec.toVector4d() // returns vector4d, w component set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR4D
// Attributes do not have signals, use onMyVecChanged instead
property vector4d myVec: "0,1,0,1"
property vector4d myVec: Qt.vector3d(0,1,0,1)
myVec.x / myVec.y / myVec.z / myVec.w
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z/w components dropped
myVec.toVector3d() // returns vector3d, w component dropped
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

//===========================================================================================================
// QML FONT
//===========================================================================================================

// FONT
// Auto converts to/from QFont
// If no matching font exists, Qt will use the closest matching installed font
// Attributes do not have signals, use onMyFontChanged instead
property font myFont: Qt.font({ family: "Helvetica", weight: Font.Black })
Qt.fontFamilies() // Returns list<string> of font families available
myFont.family // String font family name
myFont.bold // Whether bold
myFont.italic // Whether italic
myFont.underline // Whether has underline
myFont.pointSize // real, device independent
myFont.pixelSize // Overrides pointSize, int, device dependent
myFont.weight // Font Weighting Enum
myFont.overline // Whether has overline
myFont.strikeout // Whether line through it
myFont.capitalization // Font Capitalization Enum
myFont.letterSpacing // real, spacing between characters
myFont.wordSpacing // real, spacing between words
myFont.kerning // Whether to auto adjust character spacing, default enabled
myFont.preferShaping // Whether to enable display/spacing rules, default enabled
myFont.hintingPreference // Font Hinting Enum

// Font Weighting Enum
Font.Thin          Font.Normal       Font.Bold       
Font.ExtraLight    Font.Medium       Font.ExtraBold  
Font.Light         Font.DemiBold     Font.Black
  
// Font Capitalization Enum
Font.MixedCase       // No change
Font.AllUppercase    // Render in all uppercase
Font.AllLowercase    // Render in all lowercase
Font.SmallCaps       // Render in all small-caps
Font.Capitalize      // Render with the first character of each word as uppercase
  
// Font Hinting Enum
// Adjusts an outline (non-rastor) font so it lines up with a rasterized grid
// Important for displaying small text, only used with "NativeRendering"
Font.PreferDefaultHinting    // default hinting level
Font.PreferNoHinting         // render text without hinting
Font.PreferVerticalHinting   // no horizontal hinting, but align in the vertical direction
Font.PreferFullHinting       // hinting in both horizontal and vertical directions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML DYNAMIC CREATION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
// CREATE COMPONENT
// Returns a Component object created using qml url, parent can be null
// Use createObject to create an object instance of this component, will return null if failed
// incubator can be used to load instances asynchronously
var component = Qt.createComponent("MyQML.qml");
var component = Qt.createComponent("Rectangle.qml");
console.log(component.errorString());
if (component.status == Component.Ready) {
    var obj = component.createObject(parent, { x: 100, y: 100});
    var obj = component.createObject(parent, {"x": Qt.binding(function() { return item.x; })});
    
    // Using 'parent' in createObject causes issues with destroy(), use null and then .parent
    obj.parent = parent;
    obj.destroy();
    
    var incubator = component.incubateObject(parent, { x: 10, y: 10 });
    if (incubator.status != Component.Ready) {
        incubator.onStatusChanged = function(status) {
            if (status == Component.Ready) {
                var obj = incubator.object;
            }
        }
    }
}

// Component State Enum
Component.Null     // no data is available for the component
Component.Ready    // the component has been loaded, and can be used to create instances
Component.Loading  // the component is currently being loaded
Component.Error    // an error occurred while loading the component

// CREATE QML OBJECT
// Will be null if error creating object
// Any imports used here must also be at top of file
var obj = Qt.createQmlObject('import QtQuick 2.0; Rectangle {width: 20; height: 20}', parent);

// LOADER
// Dynamic loading from a URL or Component
// If an explicit size is not set for Loader, automatically resized to the size of the loaded item
// Signals emitted from the loaded object can be received using the Connections type
// Use myLoader.item to access dynamic-created item, null if not loaded
// myComponent doesn't load until used in a loader
Component { id: myComponent }
Loader {
    id: loader
    sourceComponent: myComponent // set to undefined or change to destroy items
    sourceComponent: Component { } // Supports inline
    source: "MyItem.qml" // set to "" or change to destroy items
    focus: true // must be set to true for any of its children to get the active focus
    onLoaded: {} // Signal when loading complete
}
loader.active // Set to false destroys, doesn't auto create if source/sourceComponent changes, true creates
loader.asynchronous // Default false, change to false while loading will force it to finish synchronously
loader.item // Item loaded, not available until Loader.Ready state
loader.progress // Progress real [0.0, 1.0]
loader.status // Status enum value

// Loader State Enum
Loader.Null     // the loader is inactive or no QML source has been set
Loader.Ready    // the QML source has been loaded
Loader.Loading  // the QML source is currently being loaded
Loader.Error    // an error occurred while loading the QML source

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML INPUT HANDLING
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
TAB STOP: The location the cursor stops after the tab key is pressed
ACTIVE FOCUS: Item or FocusScope child currently receiving keyboard input

COMPONENT FOCUS:
• activeFocusOnTab used to determine automatic tab ordering (default false except for Controls)
• forceActiveFocus will give a component focus
• KeyNavigation.tab / Keys.onTabPressed overrides activeFocusOnTab

COMPOSED MOUSE EVENT:
• Clicked, doubleClicked and pressAndHold, composed of basic mouse events like pressed
• Changing the accepted property of the mouse parameter has no effect unless propagateComposedEvents true

KEY HANDLING STEPS:
1) Qt receives the key action and generates a key event
2) If a QQuickWindow is the active window, the key event is delivered to it
3) The key event is delivered to the Item with active focus. If none with focus then event ignored
4) If the Item accepts the key event, propagation stops
5) If the Item declines, the event is sent to the Item's parent until the event is accepted or root reached
**************************************************************************************************************/

// FOCUSSCOPE
// Only one direct child can have focus set as true, last one set is used
// When FocusScope receives focus, the focus is auto shifted to this child
FocusScope {
    Item { focus: true }
}

// MOUSEAREA
// Inherits Item
// Only rectangle, can be child of Item or map items but not ShapePath
// Can be transformed though will call onPositionChanged when transform applied
// Do mouse.accepted = false; to send events to parent
MouseArea {
    acceptedButtons: Qt.LeftButton // default, use Qt.NoButton for just hover/wheel capture
    cursorShape: Qt.ArrowCursor // default
    drag.target: item // Item to drag
    drag.axis: Drag.XAxis // Axis mask, does not rotate
    drag.minimumX: 1.0 // how far the target can be dragged along the axis
    drag.maximumX: 1.0 // how far the target can be dragged along the axis
    drag.minimumY: 1.0 // how far the target can be dragged along the axis
    drag.maximumY: 1.0 // how far the target can be dragged along the axis
    drag.filterChildren: true // drag can override descendant MouseAreas, so parent can handle drag
    drag.threshold: 1 // determines the threshold in pixels of when the drag operation should start
    drag.smoothed: true // target will be moved only after the drag operation has started, default true
    enabled: true // overrides Item.enabled, only skips mouse events
    hoverEnabled: true // whether hover events are handled
    pressAndHoldInterval: // overrides the elapsed time in milliseconds before pressAndHold is emitted
    preventStealing: true // prevents mouse events being stolen from area by parent, default false
    propagateComposedEvents: true // sends composed events to overlapping areas in lower visual stack order
    scrollGestureEnabled: true // whether responds to scroll gestures from non-mouse device, default true
    onCanceled: {} // When another item stole the mouse event handling
    onClicked: { mouse } // Composed event, Press and release both inside area
    onDoubleClicked: { mouse } // Composed event, Press followed by a release followed by a press
    onEntered: {} // Only on press unless hoved enabled, then on enter of area
    onExit: {} // Only on press unless hoved enabled, then on exit of area
    onPositionChanged: { mouse } // Only on press unless hoved enabled, then on mouse move in area
    onPressed: { mouse } // On press
    onPressAndHold: { mouse } // Composed event, press longer than 800 ms
    onReleased: { mouse } // On release 
    onWheel: { wheel } // Mouse wheel and trackpad scroll gestures
}
area.containsMouse // whether the mouse is currently inside the mouse area
area.containsPress // pressed && containsMouse
area.drag.active // if the target item is currently being dragged
area.mouseX // local to area, valid only on press, or if hover enabled, if cursor inside area
area.mouseY // local to area, valid only on press, or if hover enabled, if cursor inside area
area.pressed // whether any of the acceptedButtons are currently pressed
area.pressedButtons // mouse buttons currently pressed, can't be Qt.AllButtons

// KEYS
// Add to any Item, each signal has key event
// Qt.Key: http://doc.qt.io/qt-5/qt.html#Key-enum
// StandardKey.Key: http://doc.qt.io/qt-5/qkeysequence.html#StandardKey-enum
Item {
    Keys.enabled: true // enable signals for this item, default true
    Keys.forwardTo: [item1, item2] // forwards event to each item, once accepted stops forwarding
    Keys.onShortcutOverride: { // Override any global Shortcut
        if (event.key == Qt.Key_Tab)
            event.accepted = true
    }
    
    Keys.onAsteriskPressed: { event }
    Keys.onBackPressed: { event }
    Keys.onBacktabPressed: { event }
    Keys.onCallPressed: { event }
    Keys.onCancelPressed: { event }
    Keys.onContext1Pressed: { event } // Supports Context1 to Context4
    Keys.onDeletePressed: { event }
    Keys.onDigit0Pressed: { event } // Supports Digit0 to Digit9
    Keys.onDownPressed: { event }
    Keys.onEnterPressed: { event }
    Keys.onEscapePressed: { event }
    Keys.onFlipPressed: { event }
    Keys.onHangupPressed: { event }
    Keys.onLeftPressed: { event }
    Keys.onMenuPressed: { event }
    Keys.onNoPressed: { event }
    Keys.onPressed: { event }
    Keys.onReleased: { event }
    Keys.onReturnPressed: { event }
    Keys.onRightPressed: { event }
    Keys.onSelectPressed: { event }
    Keys.onSpacePressed: { event }
    Keys.onTabPressed: { event }
    Keys.onUpPressed: { event }
    Keys.onVolumeDownPressed: { event }
    Keys.onVolumeUpPressed: { event }
    Keys.onYesPressed: { event }
    
    KeyNavigation.backtab: item
    KeyNavigation.down: item
    KeyNavigation.left: item
    KeyNavigation.right: item
    KeyNavigation.tab: item
    KeyNavigation.up: item
}

// MOUSE EVENT
// Use with MouseArea signals
mouse.accepted // Set to true to stop propagation to parent
mouse.button // button flag that caused the event, can't be Qt.AllButtons
mouse.buttons // mouse buttons pressed when the event was generated
mouse.modifiers // keyboard modifier flags
mouse.source // mouse event source enum
mouse.wasHeld // If the mouse button has been held pressed longer the threshold (800ms)
mouse.x // real, coordinate
mouse.y // real, coordinate

// WHEEL EVENT
// Use with MouseArea signals
wheel.accepted // Set to true to stop propagation to parent
wheel.angleDelta // QML point, degrees rotation in horizontal and vertical, up/right +, down/left -
wheel.buttons // mouse buttons pressed when the event was generated
wheel.inverted // whether the delta values delivered with the event are inverted
wheel.modifiers // keyboard modifier flags
wheel.pixelDelta // QML point, delta in screen pixels, only for high-resolution trackpad support
wheel.x // real, coordinate
wheel.y // real, coordinate

// KEY EVENT
// Use with Key signals
event.accepted // Set to true to stop propagation to parent
event.count // number of keys involved in this event
event.isAutoRepeat // whether this event comes from an auto-repeating key
event.key // holds Qt.Key code
event.modifiers // keyboard modifier flags
event.nativeScanCode // contains the native scan code of the key that was pressed
event.text // Unicode text that the key generated
event.matches(StandardKey.Undo) // Whether key event matches the given standard key

// Mouse Event Source Enum
Qt.MouseEventNotSynthesized            // Actual mouse event from user
Qt.MouseEventSynthesizedBySystemn      // Synthesized from touch or tablet event
Qt.MouseEventSynthesizedByQt           // Synthesized from an unhandled touch or tablet event by Qt
Qt.MouseEventSynthesizedByApplication  // Synthesized by the application
  
// Mouse Button Flags
Qt.RightButton          Qt.MiddleButton
Qt.LeftButton           Qt.AllButtons

// Mouse Cusor Shape Enum
Qt.BlankCursor          Qt.ForbiddenCursor        Qt.SizeAllCursor
Qt.BusyCursor           Qt.OpenHandCursor         Qt.SplitVCursor
Qt.ClosedHandCursor     Qt.PointingHandCursor     Qt.SplitHCursor
Qt.DragCopyCursor       Qt.SizeVerCursor          Qt.WaitCursor
Qt.DragMoveCursor       Qt.SizeHorCursor          Qt.WhatsThisCursor
Qt.DragLinkCursor       Qt.SizeBDiagCursor
Qt.IBeamCursor          Qt.SizeFDiagCursor

// Keyboard Modifier Flags
Qt.NoModifier           Qt.ControlModifier        Qt.MetaModifier
Qt.ShiftModifier        Qt.AltModifier            Qt.KeypadModifier

// Input Focus Reason Enum
Qt.MouseFocusReason         // A mouse action occurred
Qt.TabFocusReason           // The Tab key was pressed
Qt.BacktabFocusReason       // A Backtab occurred, may also include Tab + Shift/Control keys
Qt.ActiveWindowFocusReason  // The window system made this window either active or inactive
Qt.PopupFocusReason         // Application opened/closed a pop-up that grabbed/released the keyboard focus
Qt.ShortcutFocusReason      // The user typed a label's buddy shortcut
Qt.MenuBarFocusReason       // The menu bar took focus
Qt.OtherFocusReason         // Another reason, usually application-specific

//===========================================================================================================
// SHORTCUTS
//===========================================================================================================

// SHORTCUT
// Takes StandardKey.Key or Key String eg. "Ctrl+E,Ctrl+W"
// Takes priority over Keys.onEscapePressed etc.
// To override, use Keys.onShortcutOverride
Shortcut {
    autoRepeat: true // default true
    context: Qt.WindowShortcut // default
    sequence: StandardKey.Copy
    sequences: [StandardKey.Cut, StandardKey.Copy]
    onActivated: {}
}

// Shortcut Context Enum
Qt.WindowShortcut       // Active when its parent item is in an active top-level window
Qt.ApplicationShortcut  // Active when one of the application's windows are active

//===========================================================================================================
// DRAG / DROP
//===========================================================================================================

// DRAG
// For specifying drag and drop events for moved Items
// Change in item's position will generate a drag event sent to any DropArea that intersects new position
Item {
    Drag.active: true // Whether a drag event sequence is currently active
    Drag.dragType: Drag.Internal // Default, Drag Type Enum
    Drag.imageSource: "qrc:///icon.png" // Shown during drag event
    Drag.hotSpot: "0,0" // Default, drag position relative to the top left of the item
    Drag.keys: [] // List of keys that can be used by a DropArea to filter drag events
    Drag.mimeData: { "text/plain": "Copied text" } //  Map of mimeData that is used during startDrag
    Drag.proposedAction: Qt.CopyAction // Recommended return value of Drag.drop(), Drag Action Flags
    Drag.supportedActions: Qt.CopyAction // Return values of Drag.drop() supported, Drag Action Flags
    Drag.source: myItem // Object identified to drag events as the source of the events
    Drag.target: myItem // When active, last object to accept an enter event from the dragged item
    Drag.onDragFinished: { dropAction } // Drag/Drop Action Flags, emitted when a drag finishes 
    Drag.onDragStarted: {} // Emitted when a drag starts
}

// DROPAREA
// For specifying drag and drop handling in an area
DropArea {
    keys: [] // No keys = any source, otherwise source must also have supported keys set
    onDropped: { drop } // DragEvent, when drop event occurs within the bounds
    onEntered: { drag } // DragEvent, when drop event enters within the bounds
    onExited: { } // When drop event exits the bounds
    onPositionChanged: { drag } // DragEvent, when the position of a drag has changed
}
area.drag.x / area.drag.y // Coordinates of the last drag event
area.drag.source // Object source of a drag
area.containsDrag // whether the DropArea currently contains any dragged items

// DRAGEVENT
event.x / event.y // x/y coordinate of a drag event
event.accepted // Whether the drag event was accepted by a handler
event.action // Drag/Drop Action Flags to perform on an accepted drop
event.colorData  // holds QML color data, if any
event.drag.source // Object source of a drag
event.formats // stringlist of mime type formats contained in the drag data
event.hasColor // holds whether the drag event contains a color item
event.hasHtml // holds whether the drag event contains a html item
event.hasText // holds whether the drag event contains a text item
event.hasUrls // holds whether the drag event contains one or more url items
event.html // holds html data, if any
event.keys // stringlist of keys identifying the data type or source of a drag event
event.proposedAction // flags container of Drag/Drop Action Flags proposed by the drag source
event.supportedActions // flags container of Drag/Drop Action Flags supported by the drag source
event.text // holds text data, if any
event.urls // holds a list of urls, if any
event.accept() // Accepts the drag event
event.acceptProposedAction() // Accepts the drag event with the proposedAction
event.getDataAsArrayBuffer(format) // Returns data of format, format should be in property formats stringlist
event.getDataAsString(format) // Returns data of format, format should be in property formats stringlist

// Drag/Drop Action Flags
Qt.CopyAction      // Copy the data to the target
Qt.MoveAction      // Move the data from the source to the target
Qt.LinkAction      // Create a link from the source to the target.
Qt.IgnoreAction    // Ignore the action (do nothing with the data).

// Drag Type Enum
Drag.None          // Do not start drags automatically
Drag.Automatic     // Start drags automatically
Drag.Internal      // Start backwards compatible drags automatically

// Drag Axis Mask
Drag.XAxis
Drag.YAxis
Drag.XAndYAxis

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML GLOBAL ITEMS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
Qt.application.aboutToQuit.connect(mySlot) // Called on application exit
Qt.application.state // Read only application state enum, undefined without QGuiApplication
Qt.application.layoutDirection // Read only application layout enum, undefined without QGuiApplication
Qt.application.font // Read only default font from QGuiApplication::font, undefined without QGuiApplication
Qt.application.arguments // arguments the executable was invoked with
Qt.application.name // application name set on the QCoreApplication instance
Qt.application.displayName // application display name set on the QCoreApplication instance
Qt.application.version // application version set on the QCoreApplication instance
Qt.application.organization // organization name set on the QCoreApplication instance
Qt.application.domain // organization domain set on the QCoreApplication instance
Qt.application.supportsMultipleWindows // read only whether platform supports multiple windows
Qt.application.screens // array of QML Screen containing the descriptions of all connected screens  
Qt.platform.os // String name of platform
Qt.styleHints // QStyleHints, platform-specific style hints and settings
Qt.atob(data) // decodes the base64 encoded data string and returns it
Qt.btoa(data) // returns a base64 encoding of data
Qt.callLater(myFn, arg1, arg2...) // Call once the QML engine returns to the event loop
Qt.exit(returncode) // causes the QQmlEngine::exit(int) signal to be emitted
Qt.isQtObject(obj) // true if object is a valid reference to a Qt or QML object
Qt.md5(data) // Returns a hex string of the md5 hash of data
Qt.quit() // Quits the application

// APPLICATION STATE
Qt.ApplicationActive     // Top-most and focused, interactable
Qt.ApplicationInactive   // Not top-most or interactable but visible
Qt.ApplicationSuspended  // Not visible or running
Qt.ApplicationHidden     // Not visible but running
  
// APPLICATION LAYOUT
Qt.RightToLeft           // Text and graphics positioned right to left
Qt.LeftToRight           // Text and graphics positioned left to right

// PLATFORM TYPE
"android"   // Android
"ios"       // iOS
"linux"     // Linux
"osx"       // macOS
"unix"      // Other Unix-based OS
"windows"   // Windows

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEBUGGING QML
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QT CREATOR QML DEBUGGING
1) In the Run Settings, Debugger Settings section, select the Enable QML 
2) Window > Output Panes > Debugger Console allows executing javascript during a break
3) Use the Locals and Expressions views to explore/change the QML item structure
 
PROFILING QML
1) Ensure project built with QML debugging infrastructure
2) Run: app.exe -qmljsdebugger=port:<port>
3) Should output: QML Debugger: Waiting for connection on port <port>
4) Enter console command: qmlprofiler -p <port> -attach <ip address>
**************************************************************************************************************/

QML_IMPORT_TRACE // enable debug output from QML's import loading 
QT_DECLARATIVE_DEBUG / QT_QML_DEBUG // enable the debugging infrastructure

console.log("Message")
console.debug("Message")
console.info("Message")
console.warn("Message")
console.error("Message")
console.assert(exp, "Message on fail") // also prints stack trace
console.time("timerName") / console.timeEnd("timerName") // log the time (in milliseconds) between the calls
console.trace() // prints stack trace
console.profile() / console.profileEnd() 
console.exception("Message") // prints message and stack trace
console.count("Message") // also prints number of times called
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML OPTIMIZATIONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
PROPERTY OPTIMIZATIONS:
• Avoid declaring with var keyword unless needed
• Using a propery accesses it through cpp; faster to store result in local and access that
      var rectColor = rect.color; // resolve the common base.
      printValue("red", rectColor.r);
      printValue("green", rectColor.g)
• Avoid lots of writes to Q_PROPERTIES especially if has notify signal, pefer temp while initialising
      var tempProperty = [];
      tempProperty.length = 100;
      for (var i = 0; i < 100; ++i) {
          tempProperty[i] = i;
      }
      qProperty = tempProperty;
• Avoid binding as container[index] as it will re-evaluate when any container member is changed, do instead
      property int intermediateBinding: cointainer[index]
      property int firstBinding: intermediateBinding + x;
      property int secondBinding: intermediateBinding + y;

PROPERTY BINDING OPTIMZATIONS:
• Avoid declaring intermediate JavaScript variables
• Avoid accessing "var" properties
• Avoid calling JavaScript functions
• Avoid constructing closures or defining functions within the binding expression
• Avoid accessing properties outside of the immediate evaluation scope (non-component properties)
• Avoid writing to other properties
• Prefer binding to anchors over using another component's height/width properties

JAVASCRIPT OPTIMIZATIONS:
• Avoid using eval() if at all possible
• Do not delete properties of objects
• Trying to access nonexistent properties will always traverse the full prototype chain

COMPONENT OPTIMIZATIONS:
• If a component has a custom property, it becomes its own implicit type
  If more than one of these used, move to own file to save memory
• Consider using an asynchronous Loader component
• Prefer Item over invisible Rectangles
• For global data, use singleton types instead of pragma library scripts
  
RENDERING OPTIMIZATIONS:
• Set asynchronous property of images to true for loading
• Set sourceSize property for images to the exact size you want to ensure only what's needed is cached
• Avoid smoothing images using the smooth property
• May be better to disable bindings before and animation and re-enable once finished
• Avoid running JavaScript during animation
• Avoid enabling clipping
• Opaque faster than translucent, only one pixel needed to be considered translucent

MODEL/VIEW OPTIMIZATIONS
• Use WorkerScript with ListModel to move processing to another thread if needed
• Avoid setting the ListModel dynamicRoles property to true
• Avoid using ShaderEffect elements within delegates
• Never enable clipping on a delegate
• Use view cacheBuffer property to allow asynchronous creation and buffering of
  delegates outside of the visible area, at a memory usage increase cost
**************************************************************************************************************/
  
// WORKERSCRIPT
// Run operations in a new thread to prevent blocking of main GUI thread
// Share their own seperate Javascript heap, only allocated if WorkerScript is used
WorkerScript {
    source: "Script.js" // Script file to run in a seperate thread
    onMessage: { console.log(messageObject.result); } // Get reply from the script
}
// Script.js
WorkerScript.onMessage = function(message) {
    // Can send as: boolean, number, string, JavaScript object/array, ListModel objects
    WorkerScript.sendMessage({ "result": 0 });
}
